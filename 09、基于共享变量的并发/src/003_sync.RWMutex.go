package main

// 003、sync.RWMutex 读写锁
func main() {
	// 在 100 刀的存款消失时不做记录多少还是让我们有一些恐慌
	// Bob 写了一个程序，每秒运行几百次来检查他的银行余额，他会在家、在工作中、甚至是他手机上来运行这个程序
	// 银行注意到这些陡增的流量使得存款和取款有了延时，因为所有的余额查询请求是顺序执行的
	// 这样会获得互斥锁，并且会暂时地阻止其它 goroutine 的运行

	// 由于 Balance 函数只需要读取变量的状态，所以我们同时让多个 Balance 并发运行实际上是安全的，
	// 只要在运行的时候没有存款或者取款操作就行
	// 在这种场景下我们需要一种特殊类型的锁，其允许多个只读操作并行执行，但写操作会完全互斥
	// 这种锁叫做 “多读单写” 锁（multiple readers, single writer lock）
	// Go 语言提供的这样的锁是 sync.RWMutex
	//
	// var mu sync.RWMutex
	// var balance int
	// func Balance() int {
	// 	   mu.RLock() // 读锁
	// 	   defer mu.RUnlock()
	// 	   return balance
	// }
	//
	// Balance 函数现在调用了 RLock 和 RUnlock 方法来获取和释放一个读取或者共享锁
	// Deposit 函数没有变化，会调用 mu.Lock 和 mu.Unlock 方法来获取和释放一个写或互斥锁
	// 在这次修改后，Bob 的余额查询请求就可以彼此并行地执行并且会很快的完成了
	// 锁在更多的时间范围可用，并且存款请求也能够及时地被响应了

	// RLock 只能在临界区共享变量没有任何写入操作时可用
	// 一般来说，我们不应该假设逻辑上的只读函数/方法也不会去更新某一些变量
	// 比如一个方法功能是访问一个变量，但它也有可能会同时去给一个内部的计数器 +1
	// 或者去更新缓存，使即时的调用能够更快
	// 如果有疑惑的话，请使用互斥锁

	// RWMutex 只有当获得锁的大部分 goroutine 都是读操作，而锁在竞争条件下，
	// 也就是说，goroutine 们必须等待才能获取到锁的时候，RWMutex 才是最能带来好处的
	// RWMutex 需要更复杂的内部记录，所以会让它比一般的无竞争锁的 mutex 慢一些
}
